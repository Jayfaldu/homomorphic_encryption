package fv12

import (
	"homomorphic_encryption/poly"
)

type Fv12 struct {
	ciphertext_mod int
	plaintext_mod  int
	deg            int
	poly_mod       poly.Poly
	extra_mod      int
}

/*
Returns an variable of type Fv12 with mentioned default values
Argument :
	ciphertext_mod : modulo for coefficient of polynomial
	plaintext_mod  : modulo for coefficient of polynomial
	extra_mod	   : modulo for homomorphic multiplication
*/
func InitMods(ciphertext_mod, plaintext_mod, extra_mod int,
	poly_mod poly.Poly) Fv12 {
	return Fv12{
		ciphertext_mod: ciphertext_mod,
		plaintext_mod:  plaintext_mod,
		deg:            poly_mod.GetDeg(),
		poly_mod:       poly_mod,
		extra_mod:      extra_mod,
	}
}

/*
Generates Public key and private key
*/
func (p Fv12) Keygen() ([]poly.Poly, poly.Poly) {
	sk := poly.GenBinaryPoly(p.deg - 1)
	a := poly.GenUniformPoly(p.deg-1, p.ciphertext_mod)
	e := poly.GenNormalPoly(p.deg-1, 0, 2)

	b := poly.PolyMulModCoeffMod(a, sk, p.poly_mod, p.ciphertext_mod)
	b = poly.PolyAddModCoeffMod(b, e, p.poly_mod, p.ciphertext_mod)
	b.MulElem(-1)
	return []poly.Poly{b, a}, sk
}

/*
Encrypts a given integer
Arguments :
	public_key : public key generated by using keygen
	value : integer value to be encrypted (this value should be less
		than plaintext mod)
Returns :
		Ciphered Text for the given value
*/
func (p Fv12) Encrypt(public_key []poly.Poly, value int) []poly.Poly {

	text_poly := poly.ZeroPoly(p.deg - 1)
	_ = text_poly.SetElem(value, p.deg-1)
	delta := p.ciphertext_mod / p.plaintext_mod
	text_poly.MulElem(float64(delta))

	e1 := poly.GenNormalPoly(p.deg-1, 0, 1)
	e2 := poly.GenNormalPoly(p.deg-1, 0, 1)
	u := poly.GenBinaryPoly(p.deg - 1)

	ct0 := poly.PolyAddModCoeffMod(
		poly.PolyAddModCoeffMod(
			poly.PolyMulModCoeffMod(public_key[0], u, p.poly_mod,
				p.ciphertext_mod),
			e1, p.poly_mod, p.ciphertext_mod),
		text_poly, p.poly_mod, p.ciphertext_mod)

	ct1 := poly.PolyAddModCoeffMod(
		poly.PolyMulModCoeffMod(public_key[1], u, p.poly_mod, p.ciphertext_mod),
		e2, p.poly_mod, p.ciphertext_mod)

	return []poly.Poly{ct0, ct1}
}

/*
Decrypts the cipher text using the secret key
Argument :
	ct : cipher text to decrypt
	sk : secret key corresponding to public key
Returns :
	Decrypted value
*/
func (p Fv12) Decrypt(ct []poly.Poly, sk poly.Poly) int {

	scaled_pt := poly.PolyAddModCoeffMod(
		poly.PolyMulModCoeffMod(ct[1], sk, p.poly_mod, p.ciphertext_mod),
		ct[0], p.poly_mod, p.ciphertext_mod)

	scaled_pt.MulElem(float64(p.plaintext_mod) / float64(p.ciphertext_mod))
	scaled_pt.ModElem(p.plaintext_mod)

	decryptedval, _ := scaled_pt.GetElem(scaled_pt.GetDeg())

	return decryptedval
}

/*
Performs Homomorphic Addition
Argument :
	ct1, ct2 : cipher text to be added
Returns :
	cipher text corresponding to the addition
*/
func (p Fv12) AddCipher(ct1, ct2 []poly.Poly) []poly.Poly {
	new_ct0 := poly.PolyAddModCoeffMod(ct1[0], ct2[0], p.poly_mod,
		p.ciphertext_mod)
	new_ct1 := poly.PolyAddModCoeffMod(ct1[1], ct2[1], p.poly_mod,
		p.ciphertext_mod)
	return []poly.Poly{new_ct0, new_ct1}
}

/*
Helper function for Homomorphic Multiplication
*/
func (p Fv12) multiplicationCoeff(ct1, ct2 []poly.Poly) []poly.Poly {
	c_0 := poly.PolyMulMod(ct1[0], ct2[0], p.poly_mod)
	c_0.MulElem(float64(p.plaintext_mod) / float64(p.ciphertext_mod))
	c_0.ModElem(p.ciphertext_mod)

	c_1 := poly.PolyAddModCoeffMod(
		poly.PolyMulModCoeffMod(ct1[0], ct2[1], p.poly_mod, p.ciphertext_mod),
		poly.PolyMulModCoeffMod(ct1[1], ct2[0], p.poly_mod, p.ciphertext_mod),
		p.poly_mod, p.ciphertext_mod)
	c_1.MulElem(float64(p.plaintext_mod) / float64(p.ciphertext_mod))
	c_1.ModElem(p.ciphertext_mod)

	c_2 := poly.PolyMulMod(ct1[1], ct2[1], p.poly_mod)
	c_2.MulElem(float64(p.plaintext_mod) / float64(p.ciphertext_mod))
	c_2.ModElem(p.ciphertext_mod)

	return []poly.Poly{c_0, c_1, c_2}
}

/*
Generates relinearization keys for polynomial multiplication
Argument :
	sk : secret key
Returns :
	Corresponding Relinearization keys
*/
func (p Fv12) EvalKeygenMul(sk poly.Poly) []poly.Poly {
	new_mod := p.ciphertext_mod * p.extra_mod
	a := poly.GenUniformPoly(p.deg-1, new_mod)
	e := poly.GenNormalPoly(p.deg-1, 0, 1)
	secret_part := poly.PolyMul(sk, sk)
	secret_part.MulElem(float64(p.extra_mod))

	a.MulElem(-1)
	e.MulElem(-1)
	b := poly.PolyAddMod(
		poly.PolyMulMod(a, sk, p.poly_mod),
		poly.PolyMulMod(e, secret_part, p.poly_mod),
		p.poly_mod)
	b.ModElem(new_mod)

	a.MulElem(-1)

	return []poly.Poly{b, a}
}

/*
Performs Homomorphic Multiplication (Note: Doesn't work properly right now)
Argument :
	ct1, ct2 : cipher text to be multiplied
Returns :
	cipher text coefficient corresponding to the multiplication
*/
func (p Fv12) MulCipher(c1, c2, mulkey []poly.Poly) []poly.Poly {
	mul_coeff := p.multiplicationCoeff(c1, c2)

	c_20 := poly.PolyMulMod(mul_coeff[2], mulkey[0], p.poly_mod)
	c_20.DivElem(float64(p.extra_mod))
	c_20.ModElem(p.ciphertext_mod)

	c_21 := poly.PolyMulMod(mul_coeff[2], mulkey[1], p.poly_mod)
	c_21.DivElem(float64(p.extra_mod))
	c_21.ModElem(p.ciphertext_mod)

	new_c0 := poly.PolyAddModCoeffMod(mul_coeff[0], c_20, p.poly_mod,
		p.ciphertext_mod)
	new_c1 := poly.PolyAddModCoeffMod(mul_coeff[1], c_21, p.poly_mod,
		p.ciphertext_mod)

	return []poly.Poly{new_c0, new_c1}

}
